import sys

config(channnel is fifo, clock is lamport)

class P(process):
    def setup(s:set, nrequests:int):
        self.q = set();

    def mutex(task):

        -- request
        c = logical_clock();

        send(('request', c, self), to= s)
        q.add(('request', c , self))

        await(each(('request', c2, p)in q, has= (c2,p)==(c, self) or (c,self) < (c2, p)) and
            each(p in s, has= some(received(('ack', c2, _p)), has= c2 > c)))

        -- critical_section
        task();

        -- release
        q.remove(('request', c, self))
        send(('release', logical_clock(), self), to= s)


    def receive(msg= ('request', c2, p)):
        q.add(('request', c2, p))
        send(('ack', logical_clock(), self), to= p)

    def receive(msg= ('release', _, p)):
        for x in setof(('request', c, p), ('request', c, _p) in q):
            q.remove(x)
            break
    
    def run():
        def task():
            output('in cs')
        for i in range(nrequests):
            mutex(task)

    send(('done', self), to= parent())
    await(received(('done',), from_=parent()))
    output('terminating')

def main():
    nprocs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    nrequests = int(sys.argv[2]) if len(sys.argv) > 2 else 1

    ps = new(P, num=nprocs)

    for p in ps: setup(p, (ps-{p}, nrequests))

    start(ps)
    await(each(p in ps, has=received(('done', p))))
    send(('done',), to=ps)