# -*- generated by 1.0.12 -*-
import da
PatternExpr_306 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern309_'), da.pat.FreePattern(None)])
PatternExpr_313 = da.pat.FreePattern('a')
PatternExpr_341 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern344_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_372 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern375_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_408 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern411_'), da.pat.FreePattern(None)])
PatternExpr_415 = da.pat.FreePattern('a')
PatternExpr_482 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_487 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_563 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_570 = da.pat.FreePattern('p')
PatternExpr_576 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_605 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_631 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_685 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_698 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_760 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_765 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_829 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_855 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern858_'), da.pat.BoundPattern('_BoundPattern859_')])
PatternExpr_862 = da.pat.FreePattern('a')
PatternExpr_1352 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1357 = da.pat.BoundPattern('_BoundPattern1358_')
PatternExpr_1383 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_1390 = da.pat.FreePattern('a')
PatternExpr_1431 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_1440 = da.pat.FreePattern('ctl')
PatternExpr_1862 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1867 = da.pat.BoundPattern('_BoundPattern1868_')
PatternExpr_1893 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_1899 = da.pat.FreePattern('a')
PatternExpr_1940 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_1947 = da.pat.FreePattern('ctl')
PatternExpr_2359 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2364 = da.pat.BoundPattern('_BoundPattern2365_')
PatternExpr_2390 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_2396 = da.pat.FreePattern('a')
PatternExpr_2437 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_2444 = da.pat.FreePattern('ctl')
PatternExpr_2800 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2805 = da.pat.BoundPattern('_BoundPattern2806_')
PatternExpr_2831 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_2837 = da.pat.FreePattern('a')
PatternExpr_2875 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_2882 = da.pat.FreePattern('ctl')
PatternExpr_1359 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1365_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_1869 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1875_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2366 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2372_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2807 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2813_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
_config_object = {}
import sys
import time
import json
import csv
import random
from random import randint
controller = da.import_da('controller')
import statistics
import matplotlib.pyplot as plt
import pandas as pd

class Proposer(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ProposerReceivedEvent_0 = []
        self._ProposerReceivedEvent_1 = []
        self._ProposerReceivedEvent_2 = []
        self._ProposerReceivedEvent_3 = []
        self._ProposerReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_0', PatternExpr_306, sources=[PatternExpr_313], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_1', PatternExpr_341, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_2', PatternExpr_372, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_3', PatternExpr_408, sources=[PatternExpr_415], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_4', PatternExpr_482, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, lossrate, messagedelaytime, waittime, timeouttime, **rest_2905):
        super().setup(ctl=ctl, acceptors=acceptors, lossrate=lossrate, messagedelaytime=messagedelaytime, waittime=waittime, timeouttime=timeouttime, **rest_2905)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.lossrate = lossrate
        self._state.messagedelaytime = messagedelaytime
        self._state.waittime = waittime
        self._state.timeouttime = timeouttime
        super().setup(self._state.ctl)
        self._state.n = None
        self._state.majority = self._state.acceptors
        self._state.lossrate = self._state.lossrate
        self._state.delayTime = self._state.messagedelaytime
        self._state.waittime = self._state.waittime
        self._state.timeouttime = self._state.timeouttime
        self._state.MessageCount = 0

    @controller.run
    def run(self):
        while (not PatternExpr_487.match_iter(self._ProposerReceivedEvent_4, SELF_ID=self._id)):
            self.to_consent()
            time.sleep(self._state.waittime)
        self.output('terminating')

    def to_consent(self):
        time.sleep(self._state.delayTime)
        self._state.n = ((0, self._id) if (self._state.n == None) else ((self._state.n[0] + 1), self._id))
        self.output(self._state.lossrate)
        self.output(self._state.MessageCount)
        if (not (int(self._state.lossrate) is 0)):
            if (self._state.lossrate == self._state.MessageCount):
                self.output('Skipping this message')
                self._state.MessageCount = 0
            else:
                self.send(('prepare', self._state.n), to=self._state.majority)
                self._state.MessageCount += 1
        super()._label('_st_label_301', block=False)
        _st_label_301 = 0
        self._timer_start()
        while (_st_label_301 == 0):
            _st_label_301 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern324_, _BoundPattern326_, _)) in self._ProposerReceivedEvent_0 if (_ConstantPattern324_ == 'respond') if (_BoundPattern326_ == self._state.n)}) > (len(self._state.acceptors) / 2)):
                v = self.anyof(({v for (_, _, (_ConstantPattern360_, _BoundPattern362_, (n2, v))) in self._ProposerReceivedEvent_1 if (_ConstantPattern360_ == 'respond') if (_BoundPattern362_ == self._state.n) if (n2 == max({n2 for (_, _, (_ConstantPattern389_, _BoundPattern391_, (n2, _))) in self._ProposerReceivedEvent_2 if (_ConstantPattern389_ == 'respond') if (_BoundPattern391_ == self._state.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern426_, _BoundPattern428_, _)) in self._ProposerReceivedEvent_3 if (_ConstantPattern426_ == 'respond') if (_BoundPattern428_ == self._state.n)}
                time.sleep(self._state.delayTime)
                if (not (int(self._state.lossrate) is 0)):
                    if (self._state.lossrate == self._state.MessageCount):
                        self.output('Skipping this message')
                        self._state.MessageCount = 0
                    else:
                        self.send(('accept', self._state.n, v), to=responded)
                        self._state.MessageCount += 1
                self.debug('### chose', self._state.n, v)
                _st_label_301 += 1
            elif self._timer_expired:
                self.output('failed proposal number', self._state.n)
                _st_label_301 += 1
            else:
                super()._label('_st_label_301', block=True, timeout=self._state.timeouttime)
                _st_label_301 -= 1

    def anyof(self, s):
        return (next(iter(s)) if s else None)

@controller.rugroup('bo_measured')
class Acceptor(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._AcceptorSentEvent_1 = []
        self._AcceptorSentEvent_2 = []
        self._AcceptorSentEvent_3 = []
        self._AcceptorSentEvent_5 = []
        self._AcceptorReceivedEvent_6 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_563, sources=[PatternExpr_570], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_562]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_1', PatternExpr_576, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_2', PatternExpr_605, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_3', PatternExpr_631, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_4', PatternExpr_685, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_684]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_5', PatternExpr_698, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_6', PatternExpr_760, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, learners, lossrate, messagedelaytime, **rest_2905):
        super().setup(ctl=ctl, learners=learners, lossrate=lossrate, messagedelaytime=messagedelaytime, **rest_2905)
        self._state.ctl = ctl
        self._state.learners = learners
        self._state.lossrate = lossrate
        self._state.messagedelaytime = messagedelaytime
        super().setup(self._state.ctl)
        self._state.lossrate = self._state.lossrate
        self._state.delayTime = self._state.messagedelaytime
        self._state.MessageCount = 0

    @controller.run
    def run(self):
        super()._label('_st_label_757', block=False)
        _st_label_757 = 0
        while (_st_label_757 == 0):
            _st_label_757 += 1
            if PatternExpr_765.match_iter(self._AcceptorReceivedEvent_6, SELF_ID=self._id):
                _st_label_757 += 1
            else:
                super()._label('_st_label_757', block=True)
                _st_label_757 -= 1
        self.output('terminating')

    def anyof(self, s):
        "return any element of set s if s is not empty or 'None' otherwise"
        return (next(iter(s)) if s else None)

    def _Acceptor_handler_562(self, n, p):
        n2 = None

        def UniversalOpExpr_574():
            nonlocal n2
            for (_, _, (_ConstantPattern592_, n2, _)) in self._AcceptorSentEvent_1:
                if (_ConstantPattern592_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_574():
            maxprop = self.anyof({(n, v) for (_, _, (_ConstantPattern621_, n, v)) in self._AcceptorSentEvent_2 if (_ConstantPattern621_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern646_, n, _)) in self._AcceptorSentEvent_3 if (_ConstantPattern646_ == 'accepted')}))})
            if (not (int(self._state.lossrate) is 0)):
                if (self._state.lossrate == self._state.MessageCount):
                    self.output('Skipping this message')
                    self._state.MessageCount = 0
                else:
                    self.send(('respond', n, maxprop), to=p)
                    self._state.MessageCount += 1
    _Acceptor_handler_562._labels = None
    _Acceptor_handler_562._notlabels = None

    def _Acceptor_handler_684(self, n, v):
        n2 = None

        def ExistentialOpExpr_696():
            nonlocal n2
            for (_, _, (_ConstantPattern714_, n2, _)) in self._AcceptorSentEvent_5:
                if (_ConstantPattern714_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_696()):
            time.sleep(self._state.delayTime)
            if (not (int(self._state.lossrate) is 0)):
                if (self._state.lossrate == self._state.MessageCount):
                    self.output('Skipping this message')
                    self._state.MessageCount = 0
                else:
                    self.send(('accepted', n, v), to=self._state.learners)
                    self._state.MessageCount += 1
    _Acceptor_handler_684._labels = None
    _Acceptor_handler_684._notlabels = None

class Learner(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._LearnerReceivedEvent_0 = []
        self._LearnerReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_0', PatternExpr_829, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_1', PatternExpr_855, sources=[PatternExpr_862], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, timeouttime, **rest_2905):
        super().setup(ctl=ctl, acceptors=acceptors, timeouttime=timeouttime, **rest_2905)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.timeouttime = timeouttime
        super().setup(self._state.ctl)
        self._state.timeouttime = self._state.timeouttime
        self._state.learntvalue = (- 1)

    @controller.run
    def run(self):
        self.learn()
        self.output('terminating')
        self.send(('correctnessinfo', self._state.learntvalue), to=self.nodeof(self._id))
        self.send(('learned',), to=self.nodeof(self._id))

    def learn(self):
        super()._label('_st_label_826', block=False)
        n = a = v = None

        def ExistentialOpExpr_827():
            nonlocal n, a, v
            for (_, _, (_ConstantPattern846_, n, v)) in self._LearnerReceivedEvent_0:
                if (_ConstantPattern846_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern873_, _BoundPattern875_, _BoundPattern876_)) in self._LearnerReceivedEvent_1 if (_ConstantPattern873_ == 'accepted') if (_BoundPattern875_ == n) if (_BoundPattern876_ == v)}) > (len(self._state.acceptors) / 2)):
                        return True
            return False
        _st_label_826 = 0
        self._timer_start()
        while (_st_label_826 == 0):
            _st_label_826 += 1
            if ExistentialOpExpr_827():
                self.output('learned', n, v)
                self._state.learntvalue = v
                _st_label_826 += 1
            elif self._timer_expired:
                self.output('failed learning anything')
                _st_label_826 += 1
            else:
                super()._label('_st_label_826', block=True, timeout=self._state.timeouttime)
                _st_label_826 -= 1

def drawgraph(filename, xcoord, y1coord, y2coord, destfilename):
    csvfile = pd.read_csv(filename, nrows=None)
    x = csvfile[xcoord]
    y1 = csvfile[y1coord]
    y2 = csvfile[y2coord]
    (fig, y1config) = plt.subplots(figsize=(20, 10))
    y1config.plot(x, y1, 'k')
    y1config.set_xlabel(xcoord)
    y1config.set_ylabel(y1coord, color='k')
    y1config.tick_params('y', colors='k')
    y2config = y1config.twinx()
    y2config.plot(x, y2, 'g')
    y2config.set_ylabel(y2coord, color='g')
    y2config.tick_params('y', colors='g')
    fig.tight_layout()
    fig.savefig(destfilename)
    plt.close(fig)

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._Node_ReceivedEvent_2 = []
        self._Node_ReceivedEvent_3 = []
        self._Node_ReceivedEvent_4 = []
        self._Node_ReceivedEvent_5 = []
        self._Node_ReceivedEvent_6 = []
        self._Node_ReceivedEvent_7 = []
        self._Node_ReceivedEvent_8 = []
        self._Node_ReceivedEvent_9 = []
        self._Node_ReceivedEvent_10 = []
        self._Node_ReceivedEvent_11 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_1352, sources=[PatternExpr_1357], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_1383, sources=[PatternExpr_1390], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_2', PatternExpr_1431, sources=[PatternExpr_1440], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_3', PatternExpr_1862, sources=[PatternExpr_1867], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_4', PatternExpr_1893, sources=[PatternExpr_1899], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_5', PatternExpr_1940, sources=[PatternExpr_1947], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_6', PatternExpr_2359, sources=[PatternExpr_2364], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_7', PatternExpr_2390, sources=[PatternExpr_2396], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_8', PatternExpr_2437, sources=[PatternExpr_2444], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_9', PatternExpr_2800, sources=[PatternExpr_2805], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_10', PatternExpr_2831, sources=[PatternExpr_2837], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_11', PatternExpr_2875, sources=[PatternExpr_2882], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nacceptors = (int(sys.argv[1]) if (len(sys.argv) > 1) else 3)
        nproposers = (int(sys.argv[2]) if (len(sys.argv) > 2) else 3)
        nlearners = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        nrepititions = (int(sys.argv[4]) if (len(sys.argv) > 4) else 1)
        lossrate = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0)
        messagedelaytime = (int(sys.argv[6]) if (len(sys.argv) > 6) else 0)
        waittime = (int(sys.argv[7]) if (len(sys.argv) > 7) else 0)
        timeoutproposer = (int(sys.argv[8]) if (len(sys.argv) > 8) else 1)
        timeoutlearner = (int(sys.argv[9]) if (len(sys.argv) > 9) else 10)
        runCount = 0
        if (not (int(lossrate) is 0)):
            filemessagelossinfo = open('messagelossinfo.csv', 'a+')
            writer = csv.writer(filemessagelossinfo)
            filemesssagelossinfoconcise = open('messagelossinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filemesssagelossinfoconcise)
            writerconcise.writerow(['Message Loss Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (lossrate / 5)
            selectedlossrate = 0
            for j in range(5):
                selectedlossrate = (selectedlossrate + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, (1 / selectedlossrate), messagedelaytime, waittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, (1 / selectedlossrate), messagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_1343', block=False)
                    l = None

                    def UniversalOpExpr_1344():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_1359.match_iter(self._Node_ReceivedEvent_0, _BoundPattern1365_=l)):
                                return False
                        return True
                    _st_label_1343 = 0
                    while (_st_label_1343 == 0):
                        _st_label_1343 += 1
                        if UniversalOpExpr_1344():
                            _st_label_1343 += 1
                        else:
                            super()._label('_st_label_1343', block=True)
                            _st_label_1343 -= 1
                    else:
                        if (_st_label_1343 != 2):
                            continue
                    if (_st_label_1343 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern1401_, val)) in self._Node_ReceivedEvent_1 if (_ConstantPattern1401_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_1428', block=False)
                    itr = ctl = info = None

                    def ExistentialOpExpr_1429():
                        nonlocal itr, ctl, info
                        for (_, (_, _, ctl), (_ConstantPattern1450_, info, itr)) in self._Node_ReceivedEvent_2:
                            if (_ConstantPattern1450_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_1428 = 0
                    while (_st_label_1428 == 0):
                        _st_label_1428 += 1
                        if ExistentialOpExpr_1429():
                            data.append(info)
                            _st_label_1428 += 1
                        else:
                            super()._label('_st_label_1428', block=True)
                            _st_label_1428 -= 1
                    else:
                        if (_st_label_1428 != 2):
                            continue
                    if (_st_label_1428 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([selectedlossrate, messagedelaytime, waittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                            break
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                            break
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedlossrate, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filemessagelossinfo.close()
            filemesssagelossinfoconcise.close()
            drawgraph('messagelossinfoconcise.csv', 'Message Loss Value', 'Average CPU Time', 'Average Elapsed Time', 'messageloss.png')
        if (not (messagedelaytime is 0)):
            filemessagedelayinfo = open('messagedelayinfo.csv', 'a+')
            writer = csv.writer(filemessagedelayinfo)
            filemessagedelayinfoconcise = open('messagedelayinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filemessagedelayinfoconcise)
            writerconcise.writerow(['Message Delay Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (messagedelaytime / 5)
            selectedmessagedelaytime = 0
            for j in range(5):
                selectedmessagedelaytime = (selectedmessagedelaytime + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, int(lossrate), selectedmessagedelaytime, waittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, int(lossrate), selectedmessagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_1854', block=False)
                    l = None

                    def UniversalOpExpr_1855():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_1869.match_iter(self._Node_ReceivedEvent_3, _BoundPattern1875_=l)):
                                return False
                        return True
                    _st_label_1854 = 0
                    while (_st_label_1854 == 0):
                        _st_label_1854 += 1
                        if UniversalOpExpr_1855():
                            _st_label_1854 += 1
                        else:
                            super()._label('_st_label_1854', block=True)
                            _st_label_1854 -= 1
                    else:
                        if (_st_label_1854 != 2):
                            continue
                    if (_st_label_1854 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern1910_, val)) in self._Node_ReceivedEvent_4 if (_ConstantPattern1910_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_1937', block=False)
                    itr = ctl = info = None

                    def ExistentialOpExpr_1938():
                        nonlocal itr, ctl, info
                        for (_, (_, _, ctl), (_ConstantPattern1957_, info, itr)) in self._Node_ReceivedEvent_5:
                            if (_ConstantPattern1957_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_1937 = 0
                    while (_st_label_1937 == 0):
                        _st_label_1937 += 1
                        if ExistentialOpExpr_1938():
                            data.append(info)
                            _st_label_1937 += 1
                        else:
                            super()._label('_st_label_1937', block=True)
                            _st_label_1937 -= 1
                    else:
                        if (_st_label_1937 != 2):
                            continue
                    if (_st_label_1937 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([lossrate, selectedmessagedelaytime, waittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedmessagedelaytime, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filemessagedelayinfo.close()
            filemessagedelayinfoconcise.close()
            drawgraph('messagedelayinfoconcise.csv', 'Message Delay Value', 'Average CPU Time', 'Average Elapsed Time', 'messagedelay.png')
        if (not (waittime is 0)):
            filewaittimeinfo = open('waittimeinfo.csv', 'a+')
            writer = csv.writer(filewaittimeinfo)
            filewaittimeinfoconcise = open('filewaittimeinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filewaittimeinfoconcise)
            writerconcise.writerow(['Wait Time Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (waittime / 5)
            selectedwaittime = 0
            for j in range(5):
                selectedwaittime = (selectedwaittime + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, int(lossrate), messagedelaytime, selectedwaittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, int(lossrate), messagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_2351', block=False)
                    l = None

                    def UniversalOpExpr_2352():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_2366.match_iter(self._Node_ReceivedEvent_6, _BoundPattern2372_=l)):
                                return False
                        return True
                    _st_label_2351 = 0
                    while (_st_label_2351 == 0):
                        _st_label_2351 += 1
                        if UniversalOpExpr_2352():
                            _st_label_2351 += 1
                        else:
                            super()._label('_st_label_2351', block=True)
                            _st_label_2351 -= 1
                    else:
                        if (_st_label_2351 != 2):
                            continue
                    if (_st_label_2351 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern2407_, val)) in self._Node_ReceivedEvent_7 if (_ConstantPattern2407_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_2434', block=False)
                    itr = ctl = info = None

                    def ExistentialOpExpr_2435():
                        nonlocal itr, ctl, info
                        for (_, (_, _, ctl), (_ConstantPattern2454_, info, itr)) in self._Node_ReceivedEvent_8:
                            if (_ConstantPattern2454_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_2434 = 0
                    while (_st_label_2434 == 0):
                        _st_label_2434 += 1
                        if ExistentialOpExpr_2435():
                            data.append(info)
                            _st_label_2434 += 1
                        else:
                            super()._label('_st_label_2434', block=True)
                            _st_label_2434 -= 1
                    else:
                        if (_st_label_2434 != 2):
                            continue
                    if (_st_label_2434 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([lossrate, messagedelaytime, selectedwaittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedwaittime, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filewaittimeinfo.close()
            filewaittimeinfoconcise.close()
            drawgraph('filewaittimeinfoconcise.csv', 'Wait Time Value', 'Average CPU Time', 'Average Elapsed Time', 'waittime.png')
        if ((int(lossrate) is 0) and (waittime is 0) and (messagedelaytime is 0)):
            data = []
            for i in range(nrepititions):
                itrleantValue = []
                ctl = self.new(controller.Controller, num=1)
                self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                self._start(ctl)
                acceptors = self.new(Acceptor, num=nacceptors)
                proposers = self.new(Proposer, (ctl, acceptors, int(lossrate), messagedelaytime, waittime, timeoutproposer), num=nproposers)
                learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                for p in acceptors:
                    self._setup(p, (ctl, learners, int(lossrate), messagedelaytime))
                self._start(((acceptors | proposers) | learners))
                super()._label('_st_label_2792', block=False)
                l = None

                def UniversalOpExpr_2793():
                    nonlocal l
                    for l in learners:
                        if (not PatternExpr_2807.match_iter(self._Node_ReceivedEvent_9, _BoundPattern2813_=l)):
                            return False
                    return True
                _st_label_2792 = 0
                while (_st_label_2792 == 0):
                    _st_label_2792 += 1
                    if UniversalOpExpr_2793():
                        _st_label_2792 += 1
                    else:
                        super()._label('_st_label_2792', block=True)
                        _st_label_2792 -= 1
                else:
                    if (_st_label_2792 != 2):
                        continue
                if (_st_label_2792 != 2):
                    break
                for l in learners:
                    itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern2848_, val)) in self._Node_ReceivedEvent_10 if (_ConstantPattern2848_ == 'correctnessinfo') if (a == l)})[0])
                self.output('done')
                self.send(('done',), to=(acceptors | proposers))
                self.send(('requestperfdata', runCount), to=ctl)
                super()._label('_st_label_2872', block=False)
                itr = ctl = info = None

                def ExistentialOpExpr_2873():
                    nonlocal itr, ctl, info
                    for (_, (_, _, ctl), (_ConstantPattern2892_, info, itr)) in self._Node_ReceivedEvent_11:
                        if (_ConstantPattern2892_ == 'responseperfdata'):
                            if (runCount == itr):
                                return True
                    return False
                _st_label_2872 = 0
                while (_st_label_2872 == 0):
                    _st_label_2872 += 1
                    if ExistentialOpExpr_2873():
                        data.append(info)
                        _st_label_2872 += 1
                    else:
                        super()._label('_st_label_2872', block=True)
                        _st_label_2872 -= 1
                else:
                    if (_st_label_2872 != 2):
                        continue
                if (_st_label_2872 != 2):
                    break
