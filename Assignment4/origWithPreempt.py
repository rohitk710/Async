# -*- generated by 1.0.12 -*-
import da
PatternExpr_300 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern303_'), da.pat.FreePattern(None)])
PatternExpr_307 = da.pat.FreePattern('a')
PatternExpr_335 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern338_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_366 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern369_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_402 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern405_'), da.pat.FreePattern(None)])
PatternExpr_409 = da.pat.FreePattern('a')
PatternExpr_468 = da.pat.TuplePattern([da.pat.ConstantPattern('preempt'), da.pat.FreePattern('nnew')])
PatternExpr_502 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_507 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_583 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_590 = da.pat.FreePattern('p')
PatternExpr_596 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_625 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_651 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_705 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_736 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_749 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_809 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_814 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_878 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_904 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern907_'), da.pat.BoundPattern('_BoundPattern908_')])
PatternExpr_911 = da.pat.FreePattern('a')
PatternExpr_1399 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1404 = da.pat.BoundPattern('_BoundPattern1405_')
PatternExpr_1430 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_1437 = da.pat.FreePattern('a')
PatternExpr_1478 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_1487 = da.pat.FreePattern('ctl')
PatternExpr_1905 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1910 = da.pat.BoundPattern('_BoundPattern1911_')
PatternExpr_1936 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_1942 = da.pat.FreePattern('a')
PatternExpr_1983 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_1990 = da.pat.FreePattern('ctl')
PatternExpr_2398 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2403 = da.pat.BoundPattern('_BoundPattern2404_')
PatternExpr_2429 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_2435 = da.pat.FreePattern('a')
PatternExpr_2476 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_2483 = da.pat.FreePattern('ctl')
PatternExpr_2835 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2840 = da.pat.BoundPattern('_BoundPattern2841_')
PatternExpr_2866 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_2872 = da.pat.FreePattern('a')
PatternExpr_2910 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_2917 = da.pat.FreePattern('ctl')
PatternExpr_1406 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1412_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_1912 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1918_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2405 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2411_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2842 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2848_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
_config_object = {}
import sys
import time
import json
import csv
import random
from random import randint
controller = da.import_da('controller')
import statistics
import matplotlib.pyplot as plt
import pandas as pd

class Proposer(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ProposerReceivedEvent_0 = []
        self._ProposerReceivedEvent_1 = []
        self._ProposerReceivedEvent_2 = []
        self._ProposerReceivedEvent_3 = []
        self._ProposerReceivedEvent_4 = []
        self._ProposerReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_0', PatternExpr_300, sources=[PatternExpr_307], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_1', PatternExpr_335, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_2', PatternExpr_366, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_3', PatternExpr_402, sources=[PatternExpr_409], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_4', PatternExpr_468, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_5', PatternExpr_502, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, lossrate, messagedelaytime, waittime, timeouttime, **rest_2940):
        super().setup(ctl=ctl, acceptors=acceptors, lossrate=lossrate, messagedelaytime=messagedelaytime, waittime=waittime, timeouttime=timeouttime, **rest_2940)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.lossrate = lossrate
        self._state.messagedelaytime = messagedelaytime
        self._state.waittime = waittime
        self._state.timeouttime = timeouttime
        super().setup(self._state.ctl)
        self._state.n = None
        self._state.majority = self._state.acceptors
        self._state.lossrate = self._state.lossrate
        self._state.delayTime = self._state.messagedelaytime
        self._state.waittime = self._state.waittime
        self._state.timeouttime = self._state.timeouttime
        self._state.MessageCount = 1

    @controller.run
    def run(self):
        while (not PatternExpr_507.match_iter(self._ProposerReceivedEvent_5, SELF_ID=self._id)):
            self.to_consent()
            time.sleep(self._state.waittime)
        self.output('terminating')

    def to_consent(self):
        time.sleep(self._state.delayTime)
        self._state.n = ((0, self._id) if (self._state.n == None) else ((self._state.n[0] + 1), self._id))
        if ((not (self._state.lossrate == 0.0)) and (self._state.lossrate < self._state.MessageCount)):
            self.output('Skipping this message')
            self._state.MessageCount = 1
        else:
            self.send(('prepare', self._state.n), to=self._state.majority)
            self._state.MessageCount += 1
        super()._label('_st_label_295', block=False)
        nnew = None

        def ExistentialOpExpr_466():
            nonlocal nnew
            for (_, _, (_ConstantPattern483_, nnew)) in self._ProposerReceivedEvent_4:
                if (_ConstantPattern483_ == 'preempt'):
                    if (nnew > self._state.n):
                        return True
            return False
        _st_label_295 = 0
        self._timer_start()
        while (_st_label_295 == 0):
            _st_label_295 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern318_, _BoundPattern320_, _)) in self._ProposerReceivedEvent_0 if (_ConstantPattern318_ == 'respond') if (_BoundPattern320_ == self._state.n)}) > (len(self._state.acceptors) / 2)):
                v = self.anyof(({v for (_, _, (_ConstantPattern354_, _BoundPattern356_, (n2, v))) in self._ProposerReceivedEvent_1 if (_ConstantPattern354_ == 'respond') if (_BoundPattern356_ == self._state.n) if (n2 == max({n2 for (_, _, (_ConstantPattern383_, _BoundPattern385_, (n2, _))) in self._ProposerReceivedEvent_2 if (_ConstantPattern383_ == 'respond') if (_BoundPattern385_ == self._state.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern420_, _BoundPattern422_, _)) in self._ProposerReceivedEvent_3 if (_ConstantPattern420_ == 'respond') if (_BoundPattern422_ == self._state.n)}
                time.sleep(self._state.delayTime)
                if ((not (self._state.lossrate == 0.0)) and (self._state.lossrate < self._state.MessageCount)):
                    self.output('Skipping this message')
                    self._state.MessageCount = 1
                else:
                    self.send(('accept', self._state.n, v), to=responded)
                    self._state.MessageCount += 1
                self.debug('### chose', self._state.n, v)
                _st_label_295 += 1
            elif ExistentialOpExpr_466():
                self._state.n = nnew
                _st_label_295 += 1
            elif self._timer_expired:
                self.output('failed proposal number', self._state.n)
                _st_label_295 += 1
            else:
                super()._label('_st_label_295', block=True, timeout=self._state.timeouttime)
                _st_label_295 -= 1

    def anyof(self, s):
        return (next(iter(s)) if s else None)

@controller.rugroup('bo_measured')
class Acceptor(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._AcceptorSentEvent_1 = []
        self._AcceptorSentEvent_2 = []
        self._AcceptorSentEvent_3 = []
        self._AcceptorSentEvent_4 = []
        self._AcceptorSentEvent_6 = []
        self._AcceptorReceivedEvent_7 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_583, sources=[PatternExpr_590], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_582]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_1', PatternExpr_596, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_2', PatternExpr_625, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_3', PatternExpr_651, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_4', PatternExpr_705, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_5', PatternExpr_736, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_735]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_6', PatternExpr_749, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_7', PatternExpr_809, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, learners, lossrate, messagedelaytime, **rest_2940):
        super().setup(ctl=ctl, learners=learners, lossrate=lossrate, messagedelaytime=messagedelaytime, **rest_2940)
        self._state.ctl = ctl
        self._state.learners = learners
        self._state.lossrate = lossrate
        self._state.messagedelaytime = messagedelaytime
        super().setup(self._state.ctl)
        self._state.lossrate = self._state.lossrate
        self._state.delayTime = self._state.messagedelaytime
        self._state.MessageCount = 1

    @controller.run
    def run(self):
        super()._label('_st_label_806', block=False)
        _st_label_806 = 0
        while (_st_label_806 == 0):
            _st_label_806 += 1
            if PatternExpr_814.match_iter(self._AcceptorReceivedEvent_7, SELF_ID=self._id):
                _st_label_806 += 1
            else:
                super()._label('_st_label_806', block=True)
                _st_label_806 -= 1
        self.output('terminating')

    def anyof(self, s):
        "return any element of set s if s is not empty or 'None' otherwise"
        return (next(iter(s)) if s else None)

    def _Acceptor_handler_582(self, n, p):
        n2 = None

        def UniversalOpExpr_594():
            nonlocal n2
            for (_, _, (_ConstantPattern612_, n2, _)) in self._AcceptorSentEvent_1:
                if (_ConstantPattern612_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_594():
            maxprop = self.anyof({(n, v) for (_, _, (_ConstantPattern641_, n, v)) in self._AcceptorSentEvent_2 if (_ConstantPattern641_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern666_, n, _)) in self._AcceptorSentEvent_3 if (_ConstantPattern666_ == 'accepted')}))})
            if ((not (self._state.lossrate == 0.0)) and (self._state.lossrate < self._state.MessageCount)):
                self.output('Skipping this message')
                self._state.MessageCount = 1
            else:
                self.send(('respond', n, maxprop), to=p)
                self._state.MessageCount += 1
        else:
            npreempt = max({n2 for (_, _, (_ConstantPattern720_, n2, _)) in self._AcceptorSentEvent_4 if (_ConstantPattern720_ == 'respond')})
            self.send(('preempt', npreempt), to=p)
    _Acceptor_handler_582._labels = None
    _Acceptor_handler_582._notlabels = None

    def _Acceptor_handler_735(self, n, v):
        n2 = None

        def ExistentialOpExpr_747():
            nonlocal n2
            for (_, _, (_ConstantPattern765_, n2, _)) in self._AcceptorSentEvent_6:
                if (_ConstantPattern765_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_747()):
            time.sleep(self._state.delayTime)
            if ((not (self._state.lossrate == 0.0)) and (self._state.lossrate < self._state.MessageCount)):
                self.output('Skipping this message')
                self._state.MessageCount = 1
            else:
                self.send(('accepted', n, v), to=self._state.learners)
                self._state.MessageCount += 1
    _Acceptor_handler_735._labels = None
    _Acceptor_handler_735._notlabels = None

class Learner(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._LearnerReceivedEvent_0 = []
        self._LearnerReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_0', PatternExpr_878, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_1', PatternExpr_904, sources=[PatternExpr_911], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, timeouttime, **rest_2940):
        super().setup(ctl=ctl, acceptors=acceptors, timeouttime=timeouttime, **rest_2940)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.timeouttime = timeouttime
        super().setup(self._state.ctl)
        self._state.timeouttime = self._state.timeouttime
        self._state.learntvalue = (- 1)

    @controller.run
    def run(self):
        self.learn()
        self.output('terminating')
        self.send(('correctnessinfo', self._state.learntvalue), to=self.nodeof(self._id))
        self.send(('learned',), to=self.nodeof(self._id))

    def learn(self):
        super()._label('_st_label_875', block=False)
        a = n = v = None

        def ExistentialOpExpr_876():
            nonlocal a, n, v
            for (_, _, (_ConstantPattern895_, n, v)) in self._LearnerReceivedEvent_0:
                if (_ConstantPattern895_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern922_, _BoundPattern924_, _BoundPattern925_)) in self._LearnerReceivedEvent_1 if (_ConstantPattern922_ == 'accepted') if (_BoundPattern924_ == n) if (_BoundPattern925_ == v)}) > (len(self._state.acceptors) / 2)):
                        return True
            return False
        _st_label_875 = 0
        self._timer_start()
        while (_st_label_875 == 0):
            _st_label_875 += 1
            if ExistentialOpExpr_876():
                self.output('learned', n, v)
                self._state.learntvalue = v
                _st_label_875 += 1
            elif self._timer_expired:
                self.output('failed learning anything')
                _st_label_875 += 1
            else:
                super()._label('_st_label_875', block=True, timeout=self._state.timeouttime)
                _st_label_875 -= 1

def drawgraph(filename, xcoord, y1coord, y2coord, destfilename):
    csvfile = pd.read_csv(filename, nrows=None)
    x = csvfile[xcoord]
    y1 = csvfile[y1coord]
    y2 = csvfile[y2coord]
    (fig, y1config) = plt.subplots(figsize=(20, 10))
    y1config.plot(x, y1, 'k')
    y1config.set_xlabel(xcoord)
    y1config.set_ylabel(y1coord, color='k')
    y1config.tick_params('y', colors='k')
    y2config = y1config.twinx()
    y2config.plot(x, y2, 'g')
    y2config.set_ylabel(y2coord, color='g')
    y2config.tick_params('y', colors='g')
    fig.tight_layout()
    fig.savefig(destfilename)
    plt.close(fig)

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._Node_ReceivedEvent_2 = []
        self._Node_ReceivedEvent_3 = []
        self._Node_ReceivedEvent_4 = []
        self._Node_ReceivedEvent_5 = []
        self._Node_ReceivedEvent_6 = []
        self._Node_ReceivedEvent_7 = []
        self._Node_ReceivedEvent_8 = []
        self._Node_ReceivedEvent_9 = []
        self._Node_ReceivedEvent_10 = []
        self._Node_ReceivedEvent_11 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_1399, sources=[PatternExpr_1404], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_1430, sources=[PatternExpr_1437], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_2', PatternExpr_1478, sources=[PatternExpr_1487], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_3', PatternExpr_1905, sources=[PatternExpr_1910], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_4', PatternExpr_1936, sources=[PatternExpr_1942], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_5', PatternExpr_1983, sources=[PatternExpr_1990], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_6', PatternExpr_2398, sources=[PatternExpr_2403], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_7', PatternExpr_2429, sources=[PatternExpr_2435], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_8', PatternExpr_2476, sources=[PatternExpr_2483], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_9', PatternExpr_2835, sources=[PatternExpr_2840], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_10', PatternExpr_2866, sources=[PatternExpr_2872], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_11', PatternExpr_2910, sources=[PatternExpr_2917], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nacceptors = (int(sys.argv[1]) if (len(sys.argv) > 1) else 3)
        nproposers = (int(sys.argv[2]) if (len(sys.argv) > 2) else 3)
        nlearners = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        nrepititions = (int(sys.argv[4]) if (len(sys.argv) > 4) else 1)
        lossrate = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0)
        messagedelaytime = (int(sys.argv[6]) if (len(sys.argv) > 6) else 0)
        waittime = (int(sys.argv[7]) if (len(sys.argv) > 7) else 0)
        timeoutproposer = (int(sys.argv[8]) if (len(sys.argv) > 8) else 10)
        timeoutlearner = (int(sys.argv[9]) if (len(sys.argv) > 9) else 10)
        runCount = 0
        if (not (lossrate == 0.0)):
            filemessagelossinfo = open('messagelossinfo.csv', 'a+')
            writer = csv.writer(filemessagelossinfo)
            filemesssagelossinfoconcise = open('messagelossinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filemesssagelossinfoconcise)
            writerconcise.writerow(['Message Loss Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (lossrate / 5)
            selectedlossrate = 0
            for j in range(5):
                selectedlossrate = (selectedlossrate + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, (1 / selectedlossrate), messagedelaytime, waittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, (1 / selectedlossrate), messagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_1390', block=False)
                    l = None

                    def UniversalOpExpr_1391():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_1406.match_iter(self._Node_ReceivedEvent_0, _BoundPattern1412_=l)):
                                return False
                        return True
                    _st_label_1390 = 0
                    while (_st_label_1390 == 0):
                        _st_label_1390 += 1
                        if UniversalOpExpr_1391():
                            _st_label_1390 += 1
                        else:
                            super()._label('_st_label_1390', block=True)
                            _st_label_1390 -= 1
                    else:
                        if (_st_label_1390 != 2):
                            continue
                    if (_st_label_1390 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern1448_, val)) in self._Node_ReceivedEvent_1 if (_ConstantPattern1448_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_1475', block=False)
                    itr = ctl = info = None

                    def ExistentialOpExpr_1476():
                        nonlocal itr, ctl, info
                        for (_, (_, _, ctl), (_ConstantPattern1497_, info, itr)) in self._Node_ReceivedEvent_2:
                            if (_ConstantPattern1497_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_1475 = 0
                    while (_st_label_1475 == 0):
                        _st_label_1475 += 1
                        if ExistentialOpExpr_1476():
                            data.append(info)
                            _st_label_1475 += 1
                        else:
                            super()._label('_st_label_1475', block=True)
                            _st_label_1475 -= 1
                    else:
                        if (_st_label_1475 != 2):
                            continue
                    if (_st_label_1475 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([selectedlossrate, messagedelaytime, waittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                            break
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                            break
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedlossrate, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filemessagelossinfo.close()
            filemesssagelossinfoconcise.close()
            drawgraph('messagelossinfoconcise.csv', 'Message Loss Value', 'Average CPU Time', 'Average Elapsed Time', 'messageloss.png')
        if (not (messagedelaytime == 0)):
            filemessagedelayinfo = open('messagedelayinfo.csv', 'a+')
            writer = csv.writer(filemessagedelayinfo)
            filemessagedelayinfoconcise = open('messagedelayinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filemessagedelayinfoconcise)
            writerconcise.writerow(['Message Delay Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (messagedelaytime / 5)
            selectedmessagedelaytime = 0
            for j in range(5):
                selectedmessagedelaytime = (selectedmessagedelaytime + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, lossrate, selectedmessagedelaytime, waittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, lossrate, selectedmessagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_1897', block=False)
                    l = None

                    def UniversalOpExpr_1898():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_1912.match_iter(self._Node_ReceivedEvent_3, _BoundPattern1918_=l)):
                                return False
                        return True
                    _st_label_1897 = 0
                    while (_st_label_1897 == 0):
                        _st_label_1897 += 1
                        if UniversalOpExpr_1898():
                            _st_label_1897 += 1
                        else:
                            super()._label('_st_label_1897', block=True)
                            _st_label_1897 -= 1
                    else:
                        if (_st_label_1897 != 2):
                            continue
                    if (_st_label_1897 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern1953_, val)) in self._Node_ReceivedEvent_4 if (_ConstantPattern1953_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_1980', block=False)
                    itr = ctl = info = None

                    def ExistentialOpExpr_1981():
                        nonlocal itr, ctl, info
                        for (_, (_, _, ctl), (_ConstantPattern2000_, info, itr)) in self._Node_ReceivedEvent_5:
                            if (_ConstantPattern2000_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_1980 = 0
                    while (_st_label_1980 == 0):
                        _st_label_1980 += 1
                        if ExistentialOpExpr_1981():
                            data.append(info)
                            _st_label_1980 += 1
                        else:
                            super()._label('_st_label_1980', block=True)
                            _st_label_1980 -= 1
                    else:
                        if (_st_label_1980 != 2):
                            continue
                    if (_st_label_1980 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([lossrate, selectedmessagedelaytime, waittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedmessagedelaytime, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filemessagedelayinfo.close()
            filemessagedelayinfoconcise.close()
            drawgraph('messagedelayinfoconcise.csv', 'Message Delay Value', 'Average CPU Time', 'Average Elapsed Time', 'messagedelay.png')
        if (not (waittime == 0)):
            filewaittimeinfo = open('waittimeinfo.csv', 'a+')
            writer = csv.writer(filewaittimeinfo)
            filewaittimeinfoconcise = open('filewaittimeinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filewaittimeinfoconcise)
            writerconcise.writerow(['Wait Time Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (waittime / 5)
            selectedwaittime = 0
            for j in range(5):
                selectedwaittime = (selectedwaittime + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, lossrate, messagedelaytime, selectedwaittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, lossrate, messagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_2390', block=False)
                    l = None

                    def UniversalOpExpr_2391():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_2405.match_iter(self._Node_ReceivedEvent_6, _BoundPattern2411_=l)):
                                return False
                        return True
                    _st_label_2390 = 0
                    while (_st_label_2390 == 0):
                        _st_label_2390 += 1
                        if UniversalOpExpr_2391():
                            _st_label_2390 += 1
                        else:
                            super()._label('_st_label_2390', block=True)
                            _st_label_2390 -= 1
                    else:
                        if (_st_label_2390 != 2):
                            continue
                    if (_st_label_2390 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern2446_, val)) in self._Node_ReceivedEvent_7 if (_ConstantPattern2446_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_2473', block=False)
                    itr = ctl = info = None

                    def ExistentialOpExpr_2474():
                        nonlocal itr, ctl, info
                        for (_, (_, _, ctl), (_ConstantPattern2493_, info, itr)) in self._Node_ReceivedEvent_8:
                            if (_ConstantPattern2493_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_2473 = 0
                    while (_st_label_2473 == 0):
                        _st_label_2473 += 1
                        if ExistentialOpExpr_2474():
                            data.append(info)
                            _st_label_2473 += 1
                        else:
                            super()._label('_st_label_2473', block=True)
                            _st_label_2473 -= 1
                    else:
                        if (_st_label_2473 != 2):
                            continue
                    if (_st_label_2473 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([lossrate, messagedelaytime, selectedwaittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedwaittime, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filewaittimeinfo.close()
            filewaittimeinfoconcise.close()
            drawgraph('filewaittimeinfoconcise.csv', 'Wait Time Value', 'Average CPU Time', 'Average Elapsed Time', 'waittime.png')
        if ((lossrate == 0.0) and (waittime == 0) and (messagedelaytime == 0)):
            self.output('no where')
            data = []
            for i in range(nrepititions):
                itrleantValue = []
                ctl = self.new(controller.Controller, num=1)
                self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                self._start(ctl)
                acceptors = self.new(Acceptor, num=nacceptors)
                proposers = self.new(Proposer, (ctl, acceptors, lossrate, messagedelaytime, waittime, timeoutproposer), num=nproposers)
                learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                for p in acceptors:
                    self._setup(p, (ctl, learners, lossrate, messagedelaytime))
                self._start(((acceptors | proposers) | learners))
                super()._label('_st_label_2827', block=False)
                l = None

                def UniversalOpExpr_2828():
                    nonlocal l
                    for l in learners:
                        if (not PatternExpr_2842.match_iter(self._Node_ReceivedEvent_9, _BoundPattern2848_=l)):
                            return False
                    return True
                _st_label_2827 = 0
                while (_st_label_2827 == 0):
                    _st_label_2827 += 1
                    if UniversalOpExpr_2828():
                        _st_label_2827 += 1
                    else:
                        super()._label('_st_label_2827', block=True)
                        _st_label_2827 -= 1
                else:
                    if (_st_label_2827 != 2):
                        continue
                if (_st_label_2827 != 2):
                    break
                for l in learners:
                    itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern2883_, val)) in self._Node_ReceivedEvent_10 if (_ConstantPattern2883_ == 'correctnessinfo') if (a == l)})[0])
                self.output('done')
                self.send(('done',), to=(acceptors | proposers))
                self.send(('requestperfdata', runCount), to=ctl)
                super()._label('_st_label_2907', block=False)
                itr = ctl = info = None

                def ExistentialOpExpr_2908():
                    nonlocal itr, ctl, info
                    for (_, (_, _, ctl), (_ConstantPattern2927_, info, itr)) in self._Node_ReceivedEvent_11:
                        if (_ConstantPattern2927_ == 'responseperfdata'):
                            if (runCount == itr):
                                return True
                    return False
                _st_label_2907 = 0
                while (_st_label_2907 == 0):
                    _st_label_2907 += 1
                    if ExistentialOpExpr_2908():
                        data.append(info)
                        _st_label_2907 += 1
                    else:
                        super()._label('_st_label_2907', block=True)
                        _st_label_2907 -= 1
                else:
                    if (_st_label_2907 != 2):
                        continue
                if (_st_label_2907 != 2):
                    break
