# -*- generated by 1.0.12 -*-
import da
PatternExpr_302 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern305_'), da.pat.FreePattern(None)])
PatternExpr_309 = da.pat.FreePattern('a')
PatternExpr_337 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern340_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_368 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern371_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_404 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern407_'), da.pat.FreePattern(None)])
PatternExpr_411 = da.pat.FreePattern('a')
PatternExpr_470 = da.pat.TuplePattern([da.pat.ConstantPattern('preempt'), da.pat.FreePattern('nnew')])
PatternExpr_504 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_509 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_586 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_593 = da.pat.FreePattern('p')
PatternExpr_599 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_628 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_654 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_708 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_739 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_752 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_812 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_817 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_881 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_907 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern910_'), da.pat.BoundPattern('_BoundPattern911_')])
PatternExpr_914 = da.pat.FreePattern('a')
PatternExpr_1404 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1409 = da.pat.BoundPattern('_BoundPattern1410_')
PatternExpr_1435 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_1442 = da.pat.FreePattern('a')
PatternExpr_1483 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_1492 = da.pat.FreePattern('ctl')
PatternExpr_1914 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1919 = da.pat.BoundPattern('_BoundPattern1920_')
PatternExpr_1945 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_1951 = da.pat.FreePattern('a')
PatternExpr_1992 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_1999 = da.pat.FreePattern('ctl')
PatternExpr_2411 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2416 = da.pat.BoundPattern('_BoundPattern2417_')
PatternExpr_2442 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_2448 = da.pat.FreePattern('a')
PatternExpr_2489 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_2496 = da.pat.FreePattern('ctl')
PatternExpr_2850 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2855 = da.pat.BoundPattern('_BoundPattern2856_')
PatternExpr_2881 = da.pat.TuplePattern([da.pat.ConstantPattern('correctnessinfo'), da.pat.FreePattern('val')])
PatternExpr_2887 = da.pat.FreePattern('a')
PatternExpr_2925 = da.pat.TuplePattern([da.pat.ConstantPattern('responseperfdata'), da.pat.FreePattern('info'), da.pat.FreePattern('itr')])
PatternExpr_2932 = da.pat.FreePattern('ctl')
PatternExpr_1411 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1417_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_1921 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1927_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2418 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2424_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2857 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2863_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
_config_object = {}
import sys
import time
import json
import csv
import random
from random import randint
controller = da.import_da('controller')
import statistics
import matplotlib.pyplot as plt
import pandas as pd

class Proposer(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ProposerReceivedEvent_0 = []
        self._ProposerReceivedEvent_1 = []
        self._ProposerReceivedEvent_2 = []
        self._ProposerReceivedEvent_3 = []
        self._ProposerReceivedEvent_4 = []
        self._ProposerReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_0', PatternExpr_302, sources=[PatternExpr_309], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_1', PatternExpr_337, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_2', PatternExpr_368, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_3', PatternExpr_404, sources=[PatternExpr_411], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_4', PatternExpr_470, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_5', PatternExpr_504, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, lossrate, messagedelaytime, waittime, timeouttime, **rest_2955):
        super().setup(ctl=ctl, acceptors=acceptors, lossrate=lossrate, messagedelaytime=messagedelaytime, waittime=waittime, timeouttime=timeouttime, **rest_2955)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.lossrate = lossrate
        self._state.messagedelaytime = messagedelaytime
        self._state.waittime = waittime
        self._state.timeouttime = timeouttime
        super().setup(self._state.ctl)
        self._state.n = None
        self._state.majority = self._state.acceptors
        self._state.lossrate = self._state.lossrate
        self._state.delayTime = self._state.messagedelaytime
        self._state.waittime = self._state.waittime
        self._state.timeouttime = self._state.timeouttime
        self._state.MessageCount = 0

    @controller.run
    def run(self):
        while (not PatternExpr_509.match_iter(self._ProposerReceivedEvent_5, SELF_ID=self._id)):
            self.to_consent()
            time.sleep(self._state.waittime)
        self.output('terminating')

    def to_consent(self):
        time.sleep(self._state.delayTime)
        self._state.n = ((0, self._id) if (self._state.n == None) else ((self._state.n[0] + 1), self._id))
        if ((self._state.lossrate == self._state.MessageCount) and (not (self._state.lossrate == 0))):
            self.output(self._state.lossrate)
            self.output('Skipping this message')
            self._state.MessageCount = 0
        else:
            self.send(('prepare', self._state.n), to=self._state.majority)
            self._state.MessageCount += 1
        super()._label('_st_label_297', block=False)
        nnew = None

        def ExistentialOpExpr_468():
            nonlocal nnew
            for (_, _, (_ConstantPattern485_, nnew)) in self._ProposerReceivedEvent_4:
                if (_ConstantPattern485_ == 'preempt'):
                    if (nnew > self._state.n):
                        return True
            return False
        _st_label_297 = 0
        self._timer_start()
        while (_st_label_297 == 0):
            _st_label_297 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern320_, _BoundPattern322_, _)) in self._ProposerReceivedEvent_0 if (_ConstantPattern320_ == 'respond') if (_BoundPattern322_ == self._state.n)}) > (len(self._state.acceptors) / 2)):
                v = self.anyof(({v for (_, _, (_ConstantPattern356_, _BoundPattern358_, (n2, v))) in self._ProposerReceivedEvent_1 if (_ConstantPattern356_ == 'respond') if (_BoundPattern358_ == self._state.n) if (n2 == max({n2 for (_, _, (_ConstantPattern385_, _BoundPattern387_, (n2, _))) in self._ProposerReceivedEvent_2 if (_ConstantPattern385_ == 'respond') if (_BoundPattern387_ == self._state.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern422_, _BoundPattern424_, _)) in self._ProposerReceivedEvent_3 if (_ConstantPattern422_ == 'respond') if (_BoundPattern424_ == self._state.n)}
                time.sleep(self._state.delayTime)
                if ((self._state.lossrate == self._state.MessageCount) and (not (self._state.lossrate == 0))):
                    self.output('Skipping this message')
                    self._state.MessageCount = 0
                else:
                    self.send(('accept', self._state.n, v), to=responded)
                    self._state.MessageCount += 1
                self.debug('### chose', self._state.n, v)
                _st_label_297 += 1
            elif ExistentialOpExpr_468():
                self._state.n = nnew
                _st_label_297 += 1
            elif self._timer_expired:
                self.output('failed proposal number', self._state.n)
                _st_label_297 += 1
            else:
                super()._label('_st_label_297', block=True, timeout=self._state.timeouttime)
                _st_label_297 -= 1

    def anyof(self, s):
        return (next(iter(s)) if s else None)

@controller.rugroup('bo_measured')
class Acceptor(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._AcceptorSentEvent_1 = []
        self._AcceptorSentEvent_2 = []
        self._AcceptorSentEvent_3 = []
        self._AcceptorSentEvent_4 = []
        self._AcceptorSentEvent_6 = []
        self._AcceptorReceivedEvent_7 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_586, sources=[PatternExpr_593], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_585]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_1', PatternExpr_599, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_2', PatternExpr_628, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_3', PatternExpr_654, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_4', PatternExpr_708, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_5', PatternExpr_739, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_738]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_6', PatternExpr_752, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_7', PatternExpr_812, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, learners, lossrate, messagedelaytime, **rest_2955):
        super().setup(ctl=ctl, learners=learners, lossrate=lossrate, messagedelaytime=messagedelaytime, **rest_2955)
        self._state.ctl = ctl
        self._state.learners = learners
        self._state.lossrate = lossrate
        self._state.messagedelaytime = messagedelaytime
        super().setup(self._state.ctl)
        self._state.lossrate = self._state.lossrate
        self._state.delayTime = self._state.messagedelaytime
        self._state.MessageCount = (- 1)

    @controller.run
    def run(self):
        super()._label('_st_label_809', block=False)
        _st_label_809 = 0
        while (_st_label_809 == 0):
            _st_label_809 += 1
            if PatternExpr_817.match_iter(self._AcceptorReceivedEvent_7, SELF_ID=self._id):
                _st_label_809 += 1
            else:
                super()._label('_st_label_809', block=True)
                _st_label_809 -= 1
        self.output('terminating')

    def anyof(self, s):
        "return any element of set s if s is not empty or 'None' otherwise"
        return (next(iter(s)) if s else None)

    def _Acceptor_handler_585(self, n, p):
        n2 = None

        def UniversalOpExpr_597():
            nonlocal n2
            for (_, _, (_ConstantPattern615_, n2, _)) in self._AcceptorSentEvent_1:
                if (_ConstantPattern615_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_597():
            maxprop = self.anyof({(n, v) for (_, _, (_ConstantPattern644_, n, v)) in self._AcceptorSentEvent_2 if (_ConstantPattern644_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern669_, n, _)) in self._AcceptorSentEvent_3 if (_ConstantPattern669_ == 'accepted')}))})
            if ((self._state.lossrate == self._state.MessageCount) and (not (self._state.lossrate == 0))):
                self.output('Skipping this message')
                self._state.MessageCount = 0
            else:
                self.send(('respond', n, maxprop), to=p)
                self._state.MessageCount += 1
        else:
            npreempt = max({n2 for (_, _, (_ConstantPattern723_, n2, _)) in self._AcceptorSentEvent_4 if (_ConstantPattern723_ == 'respond')})
            self.send(('preempt', npreempt), to=p)
    _Acceptor_handler_585._labels = None
    _Acceptor_handler_585._notlabels = None

    def _Acceptor_handler_738(self, n, v):
        n2 = None

        def ExistentialOpExpr_750():
            nonlocal n2
            for (_, _, (_ConstantPattern768_, n2, _)) in self._AcceptorSentEvent_6:
                if (_ConstantPattern768_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_750()):
            time.sleep(self._state.delayTime)
            if ((self._state.lossrate == self._state.MessageCount) and (not (self._state.lossrate == 0))):
                self.output('Skipping this message')
                self._state.MessageCount = 0
            else:
                self.send(('accepted', n, v), to=self._state.learners)
                self._state.MessageCount += 1
    _Acceptor_handler_738._labels = None
    _Acceptor_handler_738._notlabels = None

class Learner(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._LearnerReceivedEvent_0 = []
        self._LearnerReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_0', PatternExpr_881, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_1', PatternExpr_907, sources=[PatternExpr_914], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, acceptors, timeouttime, **rest_2955):
        super().setup(ctl=ctl, acceptors=acceptors, timeouttime=timeouttime, **rest_2955)
        self._state.ctl = ctl
        self._state.acceptors = acceptors
        self._state.timeouttime = timeouttime
        super().setup(self._state.ctl)
        self._state.timeouttime = self._state.timeouttime
        self._state.learntvalue = (- 1)

    @controller.run
    def run(self):
        self.learn()
        self.output('terminating')
        self.send(('correctnessinfo', self._state.learntvalue), to=self.nodeof(self._id))
        self.send(('learned',), to=self.nodeof(self._id))

    def learn(self):
        super()._label('_st_label_878', block=False)
        n = v = a = None

        def ExistentialOpExpr_879():
            nonlocal n, v, a
            for (_, _, (_ConstantPattern898_, n, v)) in self._LearnerReceivedEvent_0:
                if (_ConstantPattern898_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern925_, _BoundPattern927_, _BoundPattern928_)) in self._LearnerReceivedEvent_1 if (_ConstantPattern925_ == 'accepted') if (_BoundPattern927_ == n) if (_BoundPattern928_ == v)}) > (len(self._state.acceptors) / 2)):
                        return True
            return False
        _st_label_878 = 0
        self._timer_start()
        while (_st_label_878 == 0):
            _st_label_878 += 1
            if ExistentialOpExpr_879():
                self.output('learned', n, v)
                self._state.learntvalue = v
                _st_label_878 += 1
            elif self._timer_expired:
                self.output('failed learning anything')
                _st_label_878 += 1
            else:
                super()._label('_st_label_878', block=True, timeout=self._state.timeouttime)
                _st_label_878 -= 1

def drawgraph(filename, xcoord, y1coord, y2coord, destfilename):
    csvfile = pd.read_csv(filename, nrows=None)
    x = csvfile[xcoord]
    y1 = csvfile[y1coord]
    y2 = csvfile[y2coord]
    (fig, y1config) = plt.subplots(figsize=(20, 10))
    y1config.plot(x, y1, 'k')
    y1config.set_xlabel(xcoord)
    y1config.set_ylabel(y1coord, color='k')
    y1config.tick_params('y', colors='k')
    y2config = y1config.twinx()
    y2config.plot(x, y2, 'g')
    y2config.set_ylabel(y2coord, color='g')
    y2config.tick_params('y', colors='g')
    fig.tight_layout()
    fig.savefig(destfilename)
    plt.close(fig)

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._Node_ReceivedEvent_2 = []
        self._Node_ReceivedEvent_3 = []
        self._Node_ReceivedEvent_4 = []
        self._Node_ReceivedEvent_5 = []
        self._Node_ReceivedEvent_6 = []
        self._Node_ReceivedEvent_7 = []
        self._Node_ReceivedEvent_8 = []
        self._Node_ReceivedEvent_9 = []
        self._Node_ReceivedEvent_10 = []
        self._Node_ReceivedEvent_11 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_1404, sources=[PatternExpr_1409], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_1435, sources=[PatternExpr_1442], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_2', PatternExpr_1483, sources=[PatternExpr_1492], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_3', PatternExpr_1914, sources=[PatternExpr_1919], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_4', PatternExpr_1945, sources=[PatternExpr_1951], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_5', PatternExpr_1992, sources=[PatternExpr_1999], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_6', PatternExpr_2411, sources=[PatternExpr_2416], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_7', PatternExpr_2442, sources=[PatternExpr_2448], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_8', PatternExpr_2489, sources=[PatternExpr_2496], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_9', PatternExpr_2850, sources=[PatternExpr_2855], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_10', PatternExpr_2881, sources=[PatternExpr_2887], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_11', PatternExpr_2925, sources=[PatternExpr_2932], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nacceptors = (int(sys.argv[1]) if (len(sys.argv) > 1) else 3)
        nproposers = (int(sys.argv[2]) if (len(sys.argv) > 2) else 3)
        nlearners = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        nrepititions = (int(sys.argv[4]) if (len(sys.argv) > 4) else 1)
        lossrate = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0)
        messagedelaytime = (int(sys.argv[6]) if (len(sys.argv) > 6) else 0)
        waittime = (int(sys.argv[7]) if (len(sys.argv) > 7) else 0)
        timeoutproposer = (int(sys.argv[8]) if (len(sys.argv) > 8) else 1)
        timeoutlearner = (int(sys.argv[9]) if (len(sys.argv) > 9) else 10)
        runCount = 0
        if (not (lossrate == 0)):
            self.output(lossrate)
            filemessagelossinfo = open('messagelossinfo.csv', 'a+')
            writer = csv.writer(filemessagelossinfo)
            filemesssagelossinfoconcise = open('messagelossinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filemesssagelossinfoconcise)
            writerconcise.writerow(['Message Loss Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (lossrate / 5)
            selectedlossrate = 0
            for j in range(5):
                selectedlossrate = (selectedlossrate + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, (1 / selectedlossrate), messagedelaytime, waittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, (1 / selectedlossrate), messagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_1395', block=False)
                    l = None

                    def UniversalOpExpr_1396():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_1411.match_iter(self._Node_ReceivedEvent_0, _BoundPattern1417_=l)):
                                return False
                        return True
                    _st_label_1395 = 0
                    while (_st_label_1395 == 0):
                        _st_label_1395 += 1
                        if UniversalOpExpr_1396():
                            _st_label_1395 += 1
                        else:
                            super()._label('_st_label_1395', block=True)
                            _st_label_1395 -= 1
                    else:
                        if (_st_label_1395 != 2):
                            continue
                    if (_st_label_1395 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern1453_, val)) in self._Node_ReceivedEvent_1 if (_ConstantPattern1453_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_1480', block=False)
                    itr = info = ctl = None

                    def ExistentialOpExpr_1481():
                        nonlocal itr, info, ctl
                        for (_, (_, _, ctl), (_ConstantPattern1502_, info, itr)) in self._Node_ReceivedEvent_2:
                            if (_ConstantPattern1502_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_1480 = 0
                    while (_st_label_1480 == 0):
                        _st_label_1480 += 1
                        if ExistentialOpExpr_1481():
                            data.append(info)
                            _st_label_1480 += 1
                        else:
                            super()._label('_st_label_1480', block=True)
                            _st_label_1480 -= 1
                    else:
                        if (_st_label_1480 != 2):
                            continue
                    if (_st_label_1480 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([selectedlossrate, messagedelaytime, waittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                            break
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                            break
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedlossrate, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filemessagelossinfo.close()
            filemesssagelossinfoconcise.close()
            drawgraph('messagelossinfoconcise.csv', 'Message Loss Value', 'Average CPU Time', 'Average Elapsed Time', 'messageloss.png')
        if (not (messagedelaytime is 0)):
            filemessagedelayinfo = open('messagedelayinfo.csv', 'a+')
            writer = csv.writer(filemessagedelayinfo)
            filemessagedelayinfoconcise = open('messagedelayinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filemessagedelayinfoconcise)
            writerconcise.writerow(['Message Delay Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (messagedelaytime / 5)
            selectedmessagedelaytime = 0
            for j in range(5):
                selectedmessagedelaytime = (selectedmessagedelaytime + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, int(lossrate), selectedmessagedelaytime, waittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, int(lossrate), selectedmessagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_1906', block=False)
                    l = None

                    def UniversalOpExpr_1907():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_1921.match_iter(self._Node_ReceivedEvent_3, _BoundPattern1927_=l)):
                                return False
                        return True
                    _st_label_1906 = 0
                    while (_st_label_1906 == 0):
                        _st_label_1906 += 1
                        if UniversalOpExpr_1907():
                            _st_label_1906 += 1
                        else:
                            super()._label('_st_label_1906', block=True)
                            _st_label_1906 -= 1
                    else:
                        if (_st_label_1906 != 2):
                            continue
                    if (_st_label_1906 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern1962_, val)) in self._Node_ReceivedEvent_4 if (_ConstantPattern1962_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_1989', block=False)
                    itr = info = ctl = None

                    def ExistentialOpExpr_1990():
                        nonlocal itr, info, ctl
                        for (_, (_, _, ctl), (_ConstantPattern2009_, info, itr)) in self._Node_ReceivedEvent_5:
                            if (_ConstantPattern2009_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_1989 = 0
                    while (_st_label_1989 == 0):
                        _st_label_1989 += 1
                        if ExistentialOpExpr_1990():
                            data.append(info)
                            _st_label_1989 += 1
                        else:
                            super()._label('_st_label_1989', block=True)
                            _st_label_1989 -= 1
                    else:
                        if (_st_label_1989 != 2):
                            continue
                    if (_st_label_1989 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([lossrate, selectedmessagedelaytime, waittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedmessagedelaytime, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filemessagedelayinfo.close()
            filemessagedelayinfoconcise.close()
            drawgraph('messagedelayinfoconcise.csv', 'Message Delay Value', 'Average CPU Time', 'Average Elapsed Time', 'messagedelay.png')
        if (not (waittime is 0)):
            filewaittimeinfo = open('waittimeinfo.csv', 'a+')
            writer = csv.writer(filewaittimeinfo)
            filewaittimeinfoconcise = open('filewaittimeinfoconcise.csv', 'a+')
            writerconcise = csv.writer(filewaittimeinfoconcise)
            writerconcise.writerow(['Wait Time Value', 'Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
            factor = (waittime / 5)
            selectedwaittime = 0
            for j in range(5):
                selectedwaittime = (selectedwaittime + factor)
                data = []
                learntvalue = []
                for i in range(nrepititions):
                    itrleantValue = []
                    runCount += 1
                    ctl = self.new(controller.Controller, num=1)
                    self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                    self._start(ctl)
                    acceptors = self.new(Acceptor, num=nacceptors)
                    proposers = self.new(Proposer, (ctl, acceptors, int(lossrate), messagedelaytime, selectedwaittime, timeoutproposer), num=nproposers)
                    learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                    for p in acceptors:
                        self._setup(p, (ctl, learners, int(lossrate), messagedelaytime))
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_2403', block=False)
                    l = None

                    def UniversalOpExpr_2404():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_2418.match_iter(self._Node_ReceivedEvent_6, _BoundPattern2424_=l)):
                                return False
                        return True
                    _st_label_2403 = 0
                    while (_st_label_2403 == 0):
                        _st_label_2403 += 1
                        if UniversalOpExpr_2404():
                            _st_label_2403 += 1
                        else:
                            super()._label('_st_label_2403', block=True)
                            _st_label_2403 -= 1
                    else:
                        if (_st_label_2403 != 2):
                            continue
                    if (_st_label_2403 != 2):
                        break
                    for l in learners:
                        itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern2459_, val)) in self._Node_ReceivedEvent_7 if (_ConstantPattern2459_ == 'correctnessinfo') if (a == l)})[0])
                    learntvalue.append(itrleantValue)
                    self.send(('done',), to=(acceptors | proposers))
                    self.send(('requestperfdata', runCount), to=ctl)
                    super()._label('_st_label_2486', block=False)
                    itr = info = ctl = None

                    def ExistentialOpExpr_2487():
                        nonlocal itr, info, ctl
                        for (_, (_, _, ctl), (_ConstantPattern2506_, info, itr)) in self._Node_ReceivedEvent_8:
                            if (_ConstantPattern2506_ == 'responseperfdata'):
                                if (runCount == itr):
                                    return True
                        return False
                    _st_label_2486 = 0
                    while (_st_label_2486 == 0):
                        _st_label_2486 += 1
                        if ExistentialOpExpr_2487():
                            data.append(info)
                            _st_label_2486 += 1
                        else:
                            super()._label('_st_label_2486', block=True)
                            _st_label_2486 -= 1
                    else:
                        if (_st_label_2486 != 2):
                            continue
                    if (_st_label_2486 != 2):
                        break
                writer.writerow([])
                writer.writerow([])
                writer.writerow(['Message Loss Rate', 'Message Delay', 'Wait Time', 'Timeout Proposer', 'Timeout Learner'])
                writer.writerow([lossrate, messagedelaytime, selectedwaittime, timeoutproposer, timeoutlearner])
                writer.writerow(['CPU Time', 'Elapsed Time', 'Learnt Value', 'Timeout'])
                timeoutVal = []
                lstlearntvalue = []
                for learntVal in learntvalue:
                    val = learntVal[0]
                    for vals in learntVal:
                        if (vals is (- 1)):
                            lstlearntvalue.append(val)
                            timeoutVal.append(True)
                        else:
                            timeoutVal.append(False)
                            lstlearntvalue.append(vals)
                i = 0
                for item in data:
                    item.append(lstlearntvalue[i])
                    item.append(timeoutVal[i])
                    i += 1
                    writer.writerow(item)
                listcputime = [item[0] for item in data]
                listelapsedtime = [item[1] for item in data]
                writer.writerow(['Average CPU Time', 'Average Elapsed Time', 'Standard Deviation CPU Time', 'Standard Deviation Elapsed Time', 'Range Elapsed Time', 'Range CPU Time'])
                writer.writerow([((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
                writerconcise.writerow([selectedwaittime, ((1.0 * sum(listcputime)) / len(listcputime)), ((1.0 * sum(listelapsedtime)) / len(listelapsedtime)), statistics.stdev(listcputime), statistics.stdev(listelapsedtime), (max(listcputime) - min(listcputime)), (max(listelapsedtime) - min(listelapsedtime))])
            filewaittimeinfo.close()
            filewaittimeinfoconcise.close()
            drawgraph('filewaittimeinfoconcise.csv', 'Wait Time Value', 'Average CPU Time', 'Average Elapsed Time', 'waittime.png')
        if ((lossrate == 0) and (waittime == 0) and (messagedelaytime == 0)):
            data = []
            for i in range(nrepititions):
                itrleantValue = []
                ctl = self.new(controller.Controller, num=1)
                self._setup(ctl, (((nacceptors + nproposers) + nlearners),))
                self._start(ctl)
                acceptors = self.new(Acceptor, num=nacceptors)
                proposers = self.new(Proposer, (ctl, acceptors, int(lossrate), messagedelaytime, waittime, timeoutproposer), num=nproposers)
                learners = self.new(Learner, (ctl, acceptors, timeoutlearner), num=nlearners)
                for p in acceptors:
                    self._setup(p, (ctl, learners, int(lossrate), messagedelaytime))
                self._start(((acceptors | proposers) | learners))
                super()._label('_st_label_2842', block=False)
                l = None

                def UniversalOpExpr_2843():
                    nonlocal l
                    for l in learners:
                        if (not PatternExpr_2857.match_iter(self._Node_ReceivedEvent_9, _BoundPattern2863_=l)):
                            return False
                    return True
                _st_label_2842 = 0
                while (_st_label_2842 == 0):
                    _st_label_2842 += 1
                    if UniversalOpExpr_2843():
                        _st_label_2842 += 1
                    else:
                        super()._label('_st_label_2842', block=True)
                        _st_label_2842 -= 1
                else:
                    if (_st_label_2842 != 2):
                        continue
                if (_st_label_2842 != 2):
                    break
                for l in learners:
                    itrleantValue.append(list({val for (_, (_, _, a), (_ConstantPattern2898_, val)) in self._Node_ReceivedEvent_10 if (_ConstantPattern2898_ == 'correctnessinfo') if (a == l)})[0])
                self.output('done')
                self.send(('done',), to=(acceptors | proposers))
                self.send(('requestperfdata', runCount), to=ctl)
                super()._label('_st_label_2922', block=False)
                itr = info = ctl = None

                def ExistentialOpExpr_2923():
                    nonlocal itr, info, ctl
                    for (_, (_, _, ctl), (_ConstantPattern2942_, info, itr)) in self._Node_ReceivedEvent_11:
                        if (_ConstantPattern2942_ == 'responseperfdata'):
                            if (runCount == itr):
                                return True
                    return False
                _st_label_2922 = 0
                while (_st_label_2922 == 0):
                    _st_label_2922 += 1
                    if ExistentialOpExpr_2923():
                        data.append(info)
                        _st_label_2922 += 1
                    else:
                        super()._label('_st_label_2922', block=True)
                        _st_label_2922 -= 1
                else:
                    if (_st_label_2922 != 2):
                        continue
                if (_st_label_2922 != 2):
                    break
